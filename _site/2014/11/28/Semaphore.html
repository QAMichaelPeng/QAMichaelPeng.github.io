<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>semaphore</title>
    <meta name="description" content="Thinking, coding.
">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="http://QAMichaelPeng.github.io/2014/11/28/Semaphore.html">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">QAMichaelPeng</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">semaphore</h1>
    <p class="post-meta">Nov 28, 2014</p>
  </header>

  <article class="post-content">
    <p>From <a href="http://en.wikipedia.org/wiki/Semaphore_%28programming%29">wikipedia</a>, a semaphore is  a variable or abstract data type that is used for controlling access, by multiple processes, to a common resource in a parallel programming or a multi user environment. </p>

<p>A useful way to think of a semaphore is as a record of how many units of a particular resource are available, coupled with operations to safely.
Below is pseudo code for semaphore define.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="lineno">1</span> <span class="k">struct</span> <span class="n">sem</span> <span class="p">{</span>
<span class="lineno">2</span>     <span class="kt">int</span> <span class="n">count</span><span class="p">;</span> <span class="c1">// maximum count of processes that can access the sem at the same time</span>
<span class="lineno">3</span>     <span class="n">queue</span> <span class="n">q</span><span class="p">;</span> <span class="c1">// waiting queues of processes on the semaphore.</span>
<span class="lineno">4</span> <span class="p">};</span></code></pre></div>

<p>There’re 3 operations on semaphore</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="lineno"> 1</span> <span class="c1">// init sem&#39;s count to n</span>
<span class="lineno"> 2</span> <span class="n">sem_init</span><span class="p">(</span><span class="n">sem</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="lineno"> 3</span> 
<span class="lineno"> 4</span> <span class="c1">// if sem&#39;s count is &gt; 0, decrease sem&#39;s count by 1 and continue</span>
<span class="lineno"> 5</span> <span class="c1">// othewise, block and add the current thread to sem&#39;s waiting queue.</span>
<span class="lineno"> 6</span> <span class="n">wait</span><span class="p">(</span><span class="n">sem</span><span class="p">);</span>
<span class="lineno"> 7</span> 
<span class="lineno"> 8</span> <span class="c1">// increase sem&#39;s count by 1</span>
<span class="lineno"> 9</span> <span class="c1">// if there&#39;re processes in the waiting queue, pick up one and wake it up Y</span>
<span class="lineno">10</span> <span class="n">signal</span><span class="p">(</span><span class="n">sem</span><span class="p">);</span></code></pre></div>

<p>A general scenario for semaphore is the <a href="http://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem">producer consumer problem</a>. You have a buffer with N unit and lots of producer and consumer processes. You need to make sure that producer won’t add data into buffer if it’s full and consumer won’t try to remove data if the buffer is empty. </p>

<p>A typical solution for producer-consumer problem with semaphore is given below:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="lineno"> 1</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">BUFFER_SIZE</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="lineno"> 2</span> <span class="n">queue</span> <span class="n">q</span><span class="p">;</span>
<span class="lineno"> 3</span> <span class="n">semaphore</span> <span class="n">emptySem</span><span class="p">,</span> <span class="n">fullSem</span><span class="p">,</span> <span class="n">mutexSem</span><span class="p">;</span>
<span class="lineno"> 4</span> <span class="n">init_sem</span><span class="p">(</span><span class="n">emptySem</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">);</span>
<span class="lineno"> 5</span> <span class="n">init_sem</span><span class="p">(</span><span class="n">fullSem</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="lineno"> 6</span> <span class="n">init_sem</span><span class="p">(</span><span class="n">mutexSem</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="lineno"> 7</span> <span class="n">init_queue</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">);</span>
<span class="lineno"> 8</span> 
<span class="lineno"> 9</span> <span class="kt">void</span> <span class="nf">pruducer</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno">10</span>     <span class="n">wait</span><span class="p">(</span><span class="n">emptySem</span><span class="p">);</span>
<span class="lineno">11</span>     <span class="n">wait</span><span class="p">(</span><span class="n">mutexSem</span><span class="p">);</span>
<span class="lineno">12</span>     <span class="n">produce</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="lineno">13</span>     <span class="n">signal</span><span class="p">(</span><span class="n">mutexSem</span><span class="p">);</span>
<span class="lineno">14</span>     <span class="n">signal</span><span class="p">(</span><span class="n">fullSem</span><span class="p">);</span>
<span class="lineno">15</span> <span class="p">}</span>
<span class="lineno">16</span> 
<span class="lineno">17</span> <span class="kt">void</span> <span class="nf">consumer</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno">18</span>     <span class="n">wait</span><span class="p">(</span><span class="n">fullSem</span><span class="p">);</span>
<span class="lineno">19</span>     <span class="n">wait</span><span class="p">(</span><span class="n">mutexSem</span><span class="p">);</span>
<span class="lineno">20</span>     <span class="n">consume</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="lineno">21</span>     <span class="n">signal</span><span class="p">(</span><span class="n">mutexSem</span><span class="p">);</span>
<span class="lineno">22</span>     <span class="n">signal</span><span class="p">(</span><span class="n">fullSem</span><span class="p">)</span>
<span class="lineno">23</span> <span class="p">}</span></code></pre></div>

<p>Line 1~7 initialized 3 semaphores and a queue. At first we’ve 5 empty slots and 0 full slot, so set empty sem counter to 5 and full sem to 0. mutexSem just acted like a mutex and was set to 1. </p>

<p>Producer waits for empty sem at line 10. If we remove this line, more than current empty buffer’s count’s producers will call produce sequentially. If produce subroutine doesn’t perform boundary check, there’ll be a disaster. Even if produce subroutine performs boundary check and return without add extra element to queue, it still has chance to starve consumer process. Suppose we have a consumer that is waiting on mutexSem to consume the queue, in the worst case after first 5 producers that filled the buffer, the subsequent producer will 1 by 1 hold the mutexSem with nothing to do and the consumer is waiting for ever. So we must have a mechanism to block the producer while the queue is full. This is what line 10 is for.</p>

<p>Without line 11, multiple producer will access the queue concurrently and it’s a disaster.</p>


  </article>
      <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'qamichaelpeng'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">QAMichaelPeng</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>QAMichaelPeng</li>
          <li><a href="mailto:Not Available">Not Available</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/QAMichaelPeng">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">QAMichaelPeng</span>
            </a>
          </li>
          

          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Thinking, coding.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
