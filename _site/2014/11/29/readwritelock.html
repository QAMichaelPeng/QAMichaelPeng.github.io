<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>read write lock</title>
    <meta name="description" content="Thinking, coding.
">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="http://QAMichaelPeng.github.io/2014/11/29/readwritelock.html">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">QAMichaelPeng</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">read write lock</h1>
    <p class="post-meta">Nov 29, 2014</p>
  </header>

  <article class="post-content">
    <p>Read write lock is widely used in concurrent environments. It enables multiple reader to read resource concurrently but only one writer can write to it without any read action at the same time. The concept is easy to understand, but to implement a well behaved read write lock is not so easy.</p>

<p>Implement 1: two mutex for read and write, one reader count</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="lineno"> 1</span> <span class="k">class</span> <span class="nc">RWLock</span>
<span class="lineno"> 2</span> <span class="p">{</span>
<span class="lineno"> 3</span> <span class="k">private</span><span class="o">:</span>
<span class="lineno"> 4</span>     <span class="n">mutex</span> <span class="n">rlock_</span><span class="p">;</span>
<span class="lineno"> 5</span>     <span class="n">mutex</span> <span class="n">wlock_</span><span class="p">;</span>
<span class="lineno"> 6</span>     <span class="kt">int</span> <span class="n">readers_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="lineno"> 7</span> <span class="k">public</span><span class="o">:</span>
<span class="lineno"> 8</span>     <span class="kt">void</span> <span class="n">LockWrite</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno"> 9</span>         <span class="n">wlock_</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="lineno">10</span>     <span class="p">}</span>
<span class="lineno">11</span> 
<span class="lineno">12</span>     <span class="kt">void</span> <span class="n">UnlockWrite</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno">13</span>         <span class="n">wlock_</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="lineno">14</span>     <span class="p">}</span>
<span class="lineno">15</span> 
<span class="lineno">16</span>     <span class="kt">void</span> <span class="n">LockRead</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno">17</span>         <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">rlock_</span><span class="p">);</span>
<span class="lineno">18</span>         <span class="k">if</span> <span class="p">(</span><span class="n">readers_</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">19</span>             <span class="n">LockWrite</span><span class="p">();</span>
<span class="lineno">20</span>         <span class="p">}</span>
<span class="lineno">21</span>     <span class="p">}</span>
<span class="lineno">22</span> 
<span class="lineno">23</span>     <span class="kt">void</span> <span class="n">UnlockRead</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno">24</span>         <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">rlock_</span><span class="p">);</span>
<span class="lineno">25</span>         <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">readers_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">26</span>             <span class="c1">// unlock reader thread may be different from the thread who locked the writer</span>
<span class="lineno">27</span>             <span class="n">UnlockWrite</span><span class="p">();</span>
<span class="lineno">28</span>         <span class="p">}</span>
<span class="lineno">29</span>     <span class="p">}</span>
<span class="lineno">30</span> <span class="p">};</span></code></pre></div>

<p>Thereâ€™s a big drawback in the implementation that the last reader thread who call unlock writers may be different from the first thread who lock writers. It will cause undefine behavor. </p>

<ul>
  <li>
    <p><a href="http://www.cplusplus.com/reference/mutex/mutex/unlock/">std::mutex::unlock</a>:</p>

    <p>If the mutex is not currently locked by the calling thread, it causes undefined behavior.</p>
  </li>
  <li>
    <p><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms685066(v=vs.85).aspx">ReleaseMutex</a>:</p>

    <p>The ReleaseMutex function fails if the calling thread does not own the mutex object.</p>
  </li>
  <li>
    <p><a href="http://www.lehman.cuny.edu/cgi-bin/man-cgi?pthread_mutex_lock+3">pthread_mutex_unlock</a></p>

    <p>If a thread attempts to unlock a mutex that it has not  locked  or a mutex that is unlocked, undefined behavior results.</p>
  </li>
</ul>

<p>To fix the underfined behavior issue, we can use condition variable to notify between the reader and writer processes.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="lineno"> 1</span> <span class="k">class</span> <span class="nc">RWLockCV</span><span class="p">{</span>
<span class="lineno"> 2</span>     <span class="n">mutex</span> <span class="n">lock_</span><span class="p">;</span>
<span class="lineno"> 3</span>     <span class="n">condition_variable</span> <span class="n">cv_</span><span class="p">;</span>
<span class="lineno"> 4</span>     <span class="kt">int</span> <span class="n">writers_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="lineno"> 5</span>     <span class="kt">int</span> <span class="n">readers_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="lineno"> 6</span> <span class="k">public</span><span class="o">:</span>
<span class="lineno"> 7</span>     <span class="kt">void</span> <span class="n">LockWrite</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno"> 8</span>         <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">lock_</span><span class="p">);</span>
<span class="lineno"> 9</span>         <span class="k">while</span> <span class="p">(</span><span class="n">readers_</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">writers_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">cv_</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="lineno">10</span>         <span class="o">++</span><span class="n">writers_</span><span class="p">;</span>
<span class="lineno">11</span>     <span class="p">}</span>
<span class="lineno">12</span> 
<span class="lineno">13</span>     <span class="kt">void</span> <span class="n">UnlockWrite</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno">14</span>         <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">lock_</span><span class="p">);</span>
<span class="lineno">15</span>         <span class="o">--</span><span class="n">writers_</span><span class="p">;</span>
<span class="lineno">16</span>         <span class="n">cv_</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
<span class="lineno">17</span>     <span class="p">}</span>
<span class="lineno">18</span> 
<span class="lineno">19</span>     <span class="kt">void</span> <span class="n">LockRead</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno">20</span>         <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">lock_</span><span class="p">);</span>
<span class="lineno">21</span>         <span class="k">while</span> <span class="p">(</span><span class="n">writers_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">cv_</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="lineno">22</span>         <span class="o">++</span><span class="n">readers_</span><span class="p">;</span>
<span class="lineno">23</span>     <span class="p">}</span>
<span class="lineno">24</span> 
<span class="lineno">25</span>     <span class="kt">void</span> <span class="n">UnlockRead</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno">26</span>         <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">lock_</span><span class="p">);</span>
<span class="lineno">27</span>         <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">readers_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">cv_</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
<span class="lineno">28</span>     <span class="p">}</span>
<span class="lineno">29</span> <span class="p">};</span></code></pre></div>

<p>In the above code every lock and unlock pair are in a functionâ€™s scope and no lock is unlocked in another process/thread. How does it work? Letâ€™s study several cases.</p>
<ol> 
<li> Two writer process. 

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="lineno">1</span> <span class="c1">// process 1 at time t1</span>
<span class="lineno">2</span> <span class="n">writer1</span><span class="p">.</span><span class="n">LockWrite</span><span class="p">();</span>
<span class="lineno">3</span> <span class="c1">// process 2 at time t2</span>
<span class="lineno">4</span> <span class="n">Writer2</span><span class="p">.</span><span class="n">LockWrite</span><span class="p">();</span>
<span class="lineno">5</span> <span class="c1">// process 1 at time t3</span>
<span class="lineno">6</span> <span class="n">writer1</span><span class="p">.</span><span class="n">UnlockWrite</span><span class="p">();</span></code></pre></div>


At time t1, readers and writers are 0, writer1 set writers_ to 1.

At time t2, writer2 see writers_ &gt; 0, unlock and wait on cv

At time t3, writer1 set writers_ to 0, and notify all processes waiting on cv, then release the lock. Writer2 is notified, then tried to acquire the lock and acquired the lock while writer1 released it. 
</li>
<li>

One writer and one reader. Writer first acquired the lock.


<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="lineno">1</span> <span class="c1">// process 1 at time t1</span>
<span class="lineno">2</span> <span class="n">writer1</span><span class="p">.</span><span class="n">LockWrite</span><span class="p">();</span>
<span class="lineno">3</span> <span class="c1">// process 2 at time t2</span>
<span class="lineno">4</span> <span class="n">reader1</span><span class="p">.</span><span class="n">LockRead</span><span class="p">();</span>
<span class="lineno">5</span> <span class="c1">// process 1 at time t3</span>
<span class="lineno">6</span> <span class="n">writer1</span><span class="p">.</span><span class="n">UnlockWrite</span><span class="p">();</span></code></pre></div>


Similar analysis as above. Just replace writer2 with reader1.
</li>
<li>
One writer and two readers


<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="lineno">1</span> <span class="c1">// process 1 at time t1</span>
<span class="lineno">2</span> <span class="n">writer1</span><span class="p">.</span><span class="n">LockWrite</span><span class="p">();</span>
<span class="lineno">3</span> <span class="c1">// process 2 at time t2</span>
<span class="lineno">4</span> <span class="n">reader1</span><span class="p">.</span><span class="n">LockRead</span><span class="p">();</span>
<span class="lineno">5</span> <span class="c1">// process 3 at time t3</span>
<span class="lineno">6</span> <span class="n">reader2</span><span class="p">.</span><span class="n">LockWrite</span><span class="p">();</span>
<span class="lineno">7</span> <span class="c1">// process 1 at time t4</span>
<span class="lineno">8</span> <span class="n">writer1</span><span class="p">.</span><span class="n">UnlockWrite</span><span class="p">();</span></code></pre></div>

At t4 when writer1 set writers to 0 and notify all, both reader1 and reader2 will wake up and try to acquire the lock. After writer1 released the lock, if reader2 acquired the lock, it will then set readers_ to 1 and release the lock, began reading. Then reader 1 will acquire the lock, set readers_ to 2, released the lock and began read.

From this case we see the importance of notify_all. If we use notify_one in UnlockWriter, only one reader will be token up, another will still hang on the cv.
</li>
<li>
One reader and two writers.


<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="lineno">1</span> <span class="c1">// process 1 at time t1</span>
<span class="lineno">2</span> <span class="n">reader</span><span class="p">.</span><span class="n">LockRead</span><span class="p">();</span>
<span class="lineno">3</span> <span class="c1">// process 2 at time t2</span>
<span class="lineno">4</span> <span class="n">writer1</span><span class="p">.</span><span class="n">LockWrite</span><span class="p">();</span>
<span class="lineno">5</span> <span class="c1">// process 3 at time t3</span>
<span class="lineno">6</span> <span class="n">writer2</span><span class="p">.</span><span class="n">LockWrite</span><span class="p">();</span>
<span class="lineno">7</span> <span class="c1">// process 1 at time t4</span>
<span class="lineno">8</span> <span class="n">reader1</span><span class="p">.</span><span class="n">UnlockWrite</span><span class="p">();</span></code></pre></div>

At t4, when reader1 set readers_ to 0 and call cv_.notify_all, both writer1 and writer2 will wake up and try to acquire lock. After reader1 released the lock, if writer2 acquired the lock, increment writers_ to 1 and release the lock, writer1 then acquired the lock, but since writers_ is now 1, it can do nothing but wait again. <b>It's a waste if we have many writers waiting on the cv.</b> Only one can get the chance to execute, all others are woken up and soon sleep again. To solve the issue, we should use two cv: one for reader and call notify_all on that when unlock, another for writer and call notify_one when unlock.
</li>
<li>
Multiple readers starve writer.

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="lineno"> 1</span> <span class="c1">// process 1 at time t1</span>
<span class="lineno"> 2</span> <span class="n">reader</span><span class="p">.</span><span class="n">LockRead</span><span class="p">();</span>
<span class="lineno"> 3</span> <span class="c1">// process 2 at time t2</span>
<span class="lineno"> 4</span> <span class="n">writer1</span><span class="p">.</span><span class="n">LockWrite</span><span class="p">();</span>
<span class="lineno"> 5</span> <span class="c1">// process 3 at time t3</span>
<span class="lineno"> 6</span> <span class="n">reader2</span><span class="p">.</span><span class="n">LockRead</span><span class="p">();</span>
<span class="lineno"> 7</span> <span class="c1">// process 1 at time t4</span>
<span class="lineno"> 8</span> <span class="n">reader1</span><span class="p">.</span><span class="n">UnlockWrite</span><span class="p">();</span>
<span class="lineno"> 9</span> <span class="c1">// process 4 at time t5</span>
<span class="lineno">10</span> <span class="n">reader3</span><span class="p">.</span><span class="n">LockRead</span><span class="p">();</span>
<span class="lineno">11</span> <span class="c1">// process 3 at time t6</span>
<span class="lineno">12</span> <span class="n">reader2</span><span class="p">.</span><span class="n">UnlockWrite</span><span class="p">();</span></code></pre></div>


At t3, when reader2 tried to lock, it got the lock and set readers_ to 2. At t4, after reader1 unlocked, writer1 was woken up but since readers_ is 1 now, it had to wait again. At t6 when reader2 released the lock, there was a reader 3 and writer1 had to wait again. <b>So if there always came a reader before the last reader called UnlockReader, writer1 would never get a chance to execute.</b> This issue is even harder to solve. We need a queue to recors each read/write request time and make those request served in the order they come as possible as we can. In some cases we can't gurante that if a reader comes while the buffer is empty.
</li>
</ol>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">QAMichaelPeng</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>QAMichaelPeng</li>
          <li><a href="mailto:Not Available">Not Available</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/QAMichaelPeng">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">QAMichaelPeng</span>
            </a>
          </li>
          

          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Thinking, coding.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
